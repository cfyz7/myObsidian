# Как работает new this внутри статических методов
Конструкция `new this` внутри статического метода вызовет конструктор того класса, внутри которого этот метод определён, поэтому этот код
```
class Test {
  constructor(message = 'hello') {
    this.message = message;
  }
  static getNewInstance(message) {
    return new Test(message);
  }
}
```
аналогичен этому
```
class Test {
  constructor(message = 'hello') {
    this.message = message;
  }
  static getNewInstance(message) {
    return new this(message);
  }
}
```


# Что такое идентификатор "e", идущий после catch?
```
try {
   throw 'myException'; // создание исключения и прокидывание
}
catch (e) {
   // инструкции для обработки ошибок
   logMyErrors(e); // передать объект исключения обработчику ошибок
}

// Блок catch задаёт идентификатор (e в примере выше) который
// содержит объект исключения (в примере выше — значение,
// переданное оператору throw). Область видимости этого объекта
// ограничивается блоком catch.
```
В примере выше идентификатор `e` - это просто некая переменная, в которой будет то, что **прокинули** (throw). Это может быть не обязательно ошибка, например, в коде ниже прокидывается строка:
```
try {
  throw 'hello!'; // выбрасываем строку 'hello!'
} catch (e) {  // ловим то, что было выброшено (доступно в переменной "e")
  console.log(e); // => hello!
}
```
Можно выкидывать всё что угодно, это обычное выражение. И можно указывать вместо `e` любое имя. По сути к этому значению можно относится как к входящему аргументу функции (мы также можем задать любое имя):
```
try {
  throw { name: 'Ivan', age: 39 }; // выбрасываем объект
} catch (user) {  // ловим то, что было выброшено (доступно в переменной "user")
  console.log(user); // => { name: 'Ivan', age: 39 }
}
```


# Что такое трассировка стека?
Трассировка стека в выводе - это отчет, в котором содержится информация о вложенности внутри функций относительно момента, когда произошел выброс исключения. Чтобы лучше понять, рассмотрим пример:
```
const func1 = () => {
  throw Error('func1 error!');
};

const func2 = () => {
  func1();
};

const func3 = () => {
  func2();
};

try {
  func3();
} catch (e) {
  console.log(e);
}
// Вывод будет следующим (вместо anonymous будет имя файла с кодом, я запускал в консоли браузера)
// Error: func1 error!
//    at func1 (<anonymous>:3:9)
//    at func2 (<anonymous>:8:3)
//    at func3 (<anonymous>:13:3)
//    at <anonymous>:17:3
```
В коде у нас три функции, каждая из которых вызывает другую, последняя (`func1`) внутри выбрасывает ошибку. Получается такая цепочка вызовов: `func3 -> func2 -> func1`. Внутри блока `try catch` мы поймали ошибку и распечатали. По ней видно, что текст ошибки содержит не только то значение, переданное в `Error()`, но и имена функций, номера строк и позиций в строках, в которых была выброшена ошибка. Это и есть трассировка стека. По нему можно понять, что ошибка была внутри функции `func1()`, строка 3, позиция 9. Эта функция была вызвана внутри функции `func2()`, строка 8, позиция 3. Функция 2 была вызвана внутри `func3()`, строка 13, позиция 3. А функция `func3()` была вызвана на строке 17, позиция 3. Позиция указывает на номер символа (с которого начинается имя функции) с начала строки.

# В js геттеры и сеттеры это отдельные функции get, set? Как они работают?

В JS есть особый тип свойств — это свойства-аксессоры. Их особенность в том, что при обращении к этим свойствам вызываются функции, которые выполняют необходимую работу. Все взаимодействия со свойствами сводятся к двум операциям: получение значения из свойства и присваивание нового значения свойству. То есть, чтобы работать со свойством объекта, достаточно описать две операции: операцию получения значения из свойства и операцию сохранения значения в свойство. Это и есть геттеры и сеттеры. Геттер — занимается извлечением значения из свойства, а сеттер — сохранением значения. Для этого в JS есть специальный механизм, в котором ставится `get` перед геттером и `set` перед сеттером. Рассмотрим пример, в котором у нас есть пользователь с именем и фамилией:

```
const user = {
  firstName: 'Ivan',
  lastName: 'Ivanov',
};
```

И мы хотим определить третье свойство, которое бы содержало полное имя. Оно зависит от имени и фамилии, поэтому, чтобы не дублировать данные, лучше всего подойдёт геттер:

```
const user = {
  firstName: 'Ivan',
  lastName: 'Ivanov',
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

console.log(user.fullName); // => Ivan Ivanov
```

При обращении к свойству `fullName` вызывается геттер, который формирует результат и возвращает его. Также мы можем определить сеттер для этого свойства, функция будет обновлять данные о пользователе:

```
const user = {
  firstName: 'Ivan',
  lastName: 'Ivanov',
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  set fullName(fullName) {
    const [first, second] = fullName.split(' ');
    this.firstName = first;
    this.lastName = second;
  },
};

user.fullName = 'Petr Petrov';
console.log(user); // => {firstName: 'Petr', lastName: 'Petrov'}
```

При обновлении свойства, вызывается сеттер, внутри которого происходит вся необходимая работа и сохранение данных, если это необходимо.

# Что такое приватные поля с префиксом # в классах?

Приватные поля в классах с префиксом `#` в имени свойства, созданы, чтобы ограничить доступ к таким полям вне класса, такие свойства доступны лишь внутри класса. Например:

```
class MyClass {
  #message;

  setMessage(newMessage) {
    this.#message = newMessage;
  }

  getMessage() {
    return this.#message;
  }
}

const obj = new MyClass();
obj.#message = 'hello'; // Error!
```

Внутри класса `MyClass` определено приватное свойство `message`, которое не доступно вне класса. При попытке обратиться к нему напрямую (`obj.#message`), возникает ошибка. Но можно обращаться к нему через публичные методы, которые мы определили `getMessage()` и `setMessage()`:

```
obj.setMessage('hello');
console.log(obj.getMessage()); // => hello
```